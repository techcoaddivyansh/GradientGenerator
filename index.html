<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Image Generator</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8f9fa;
            height: 100vh;
            overflow-x: hidden;
        }
        .container {
            display: grid;
            grid-template-columns: 350px 1fr;
            grid-template-rows: auto 1fr;
            height: 100vh;
            background: white;
            gap: 0;
            transition: grid-template-columns 0.3s ease;
        }
        .container.sidebar-collapsed {
            grid-template-columns: 0px 1fr;
        }
        .header {
            grid-column: 1 / -1;
            background: #2c3e50;
            color: white;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header h1 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
        }
        .header p {
            margin: 0;
            font-size: 14px;
            opacity: 0.9;
        }
        .sidebar {
            background: #ecf0f1;
            padding: 15px;
            overflow-y: auto;
            overflow-x: hidden;
            border-right: 1px solid #bdc3c7;
            transition: all 0.3s ease;
            position: relative;
        }
        .sidebar.collapsed {
            margin-left: -350px;
            opacity: 0;
        }
        .sidebar-toggle {
            position: fixed;
            left: 350px;
            top: 50%;
            transform: translateY(-50%);
            background: #34495e;
            color: white;
            border: none;
            width: 30px;
            height: 60px;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 2px 0 8px rgba(0,0,0,0.15);
        }
        .sidebar-toggle:hover {
            background: #2c3e50;
            width: 32px;
        }
        .sidebar-toggle.collapsed {
            left: 0;
            border-radius: 0 8px 8px 0;
            background: #3498db;
        }
        .sidebar-toggle.collapsed:hover {
            background: #2980b9;
            width: 32px;
        }
        .main-preview {
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #ffffff;
            overflow: auto;
            width: 100%;
            min-height: 100%;
        }
        .container.sidebar-collapsed .main-preview {
            margin: 0 auto;
            max-width: none;
        }

        .gradient-preview {
            width: 758px;
            height: 315px;
            background: linear-gradient(to right, rgba(4, 3, 73, 1) 28%, rgba(4, 3, 73, 0.6) 65%, rgba(0, 0, 0, 0.4));
            border: 2px solid #bdc3c7;
            border-radius: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }
        .section {
            background: white;
            margin-bottom: 8px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            overflow: hidden;
        }
        .section:last-child {
            margin-bottom: 0;
        }
        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            cursor: pointer;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            transition: background-color 0.2s ease;
        }
        .section-header:hover {
            background: #e9ecef;
        }
        .section-header.active {
            background: #3498db;
            color: white;
        }
        .section-header h3 {
            margin: 0;
            font-size: 14px;
            color: inherit;
            font-weight: 600;
        }
        .section-toggle {
            font-size: 12px;
            font-weight: bold;
            user-select: none;
        }
        .section-content {
            padding: 0 15px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }
        .section-content.expanded {
            max-height: 60vh;
            padding: 12px;
            overflow-y: auto;
        }
        label {
            font-weight: 500;
            color: #2c3e50;
            font-size: 13px;
            margin-bottom: 4px;
        }
        input, select {
            padding: 8px 10px;
            border: 1px solid #bdc3c7;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 13px;
            width: 100%;
            min-width: 0;
        }
        input[type="number"] {
            min-width: 70px;
        }
        input:focus, select:focus {
            border-color: #3498db;
            outline: none;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
            width: 100%;
        }
        button:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }
        button:active {
            transform: translateY(0);
        }
        .size-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 12px 0;
        }
        .size-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            width: 100%;
        }
        .size-btn:hover {
            background: #229954;
            transform: translateY(-1px);
        }
        .custom-size {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }
        .custom-size input {
            margin: 0;
        }
        #downloadCanvas {
            display: none;
        }
        .color-stops {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin: 8px 0;
        }
        .color-stop {
            display: flex;
            flex-direction: column;
            gap: 6px;
            border: 1px solid #dee2e6;
            padding: 8px;
            border-radius: 6px;
            background: #f8f9fa;
            transition: all 0.2s ease;
        }
        .color-stop:hover {
            border-color: #3498db;
            transform: translateY(-1px);
        }
        .color-preview {
            width: 100%;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #bdc3c7;
            margin-bottom: 6px;
        }
        .color-input-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .color-input-row {
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 8px;
        }
        .color-input-row.color-main {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .color-input-row.color-main input[type="text"] {
            transition: all 0.3s ease;
        }
        .color-input-row.color-main input[type="text"]:focus {
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }
        .color-input-row label {
            font-size: 12px;
            min-width: 50px;
        }
        .color-input-row input[type="number"] {
            width: 60px;
            min-width: 60px;
        }
        .color-input-row         input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #dee2e6;
            border-radius: 4px;
            outline: none;
            overflow: hidden;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2), -407px 0 0 400px #3498db;
            transition: all 0.2s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #2980b9;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3), -407px 0 0 400px #2980b9;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }
        
        input[type="range"]::-moz-range-thumb:hover {
            background: #2980b9;
        }
        
        input[type="range"]::-moz-range-track {
            height: 8px;
            background: linear-gradient(to right, #3498db 0%, #3498db var(--value, 0%), #dee2e6 var(--value, 0%), #dee2e6 100%);
            border-radius: 4px;
            border: none;
        }
        .color-input-row input[type="color"] {
            width: 40px;
            height: 30px;
            padding: 0;
            border: 1px solid #bdc3c7;
        }
        .add-stop-btn {
            background: #6c757d;
            margin-top: 8px;
        }
        .add-stop-btn:hover {
            background: #5a6268;
        }
        .remove-stop-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin-top: 6px;
            width: 100%;
        }
        .remove-stop-btn:hover {
            background: #c0392b;
            transform: translateY(-1px);
        }
        .direction-control {
            margin: 0;
        }
        .feedback-message {
            display: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            animation: fadeIn 0.5s;
            max-width: 300px;
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 1001;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .success-message {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .info-message {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        .fadeOut {
            animation: fadeOut 0.5s forwards;
        }

        .image-position-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }
        .preview-container {
            position: relative;
            width: 758px;
            height: 315px;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #bdc3c7;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
            margin: 10px auto;
        }
        .container.sidebar-collapsed .preview-container {
            margin: 10px auto;
        }
        .css-code-section {
            transition: all 0.3s ease;
        }
        .container.sidebar-collapsed .css-code-section {
            display: flex !important;
            flex-direction: column !important;
            align-items: center !important;
            justify-content: center !important;
            width: 100% !important;
            margin: 20px auto 0 auto !important;
        }
        .container.sidebar-collapsed .css-code-section > div {
            max-width: 800px !important;
            width: 100% !important;
        }
        .background-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }
        .gradient-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            background: linear-gradient(to right, rgba(4, 3, 73, 1) 28%, rgba(4, 3, 73, 0.6) 65%, rgba(0, 0, 0, 0.4));
        }
        .image-upload-btn {
            background: #6c757d;
        }
        .image-upload-btn:hover {
            background: #5a6268;
        }
        .remove-image-btn {
            background: #e74c3c;
        }
        .remove-image-btn:hover {
            background: #c0392b;
        }
        .image-controls-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .image-controls-row label {
            min-width: 80px;
            font-size: 12px;
        }
        .file-upload-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        .file-upload-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        .position-fine-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin-top: 8px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }
        .position-fine-controls input[type="number"] {
            width: 100%;
            font-size: 12px;
            padding: 6px 8px;
            min-width: 60px;
        }
        .position-fine-controls .center-cell {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .position-fine-controls .arrow-btn {
            width: 32px;
            height: 32px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            background: #6c757d;
            margin: 1px;
            border-radius: 4px;
        }
        .position-fine-controls .arrow-btn:hover {
            background: #5a6268;
        }
        .position-fine-controls .reset-btn {
            background: #f39c12;
            color: white;
        }
        .position-fine-controls .reset-btn:hover {
            background: #e67e22;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div>
                <h1>Gradient Image Generator</h1>
            </div>
            <div style="display: flex; align-items: center; gap: 15px;">
                <button onclick="openDownloadPopup()" style="background: #27ae60; color: white; border: none; padding: 10px 20px; border-radius: 6px; font-size: 14px; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.background='#229954'" onmouseout="this.style.background='#27ae60'">📥 Download</button>
            </div>
        </div>
        
        <!-- Toast notification positioned absolutely -->
        <div id="feedback" class="feedback-message"></div>
        
        <button onclick="toggleSidebar()" id="sidebarToggle" class="sidebar-toggle">‹</button>
        <div class="sidebar" id="sidebar">
            <div class="section">
                <div class="section-header active" onclick="toggleSection(this)">
                    <h3>Display Settings</h3>
                    <span class="section-toggle expanded">▼</span>
                </div>
                <div class="section-content expanded">
                    <div class="control-group">
                        <label for="gradientDirection">Gradient Direction:</label>
                        <select id="gradientDirection" onchange="updateGradient()">
                            <option value="to right">Left to Right</option>
                            <option value="to left">Right to Left</option>
                            <option value="to bottom">Top to Bottom</option>
                            <option value="to top">Bottom to Top</option>
                            <option value="to bottom right">Top Left to Bottom Right</option>
                            <option value="to bottom left">Top Right to Bottom Left</option>
                            <option value="to top right">Bottom Left to Top Right</option>
                            <option value="to top left">Bottom Right to Top Left</option>
                        </select>
                    </div>
                    
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #dee2e6;">
                        <div class="control-group">
                            <label>Preview Size:</label>
                            <div class="size-options">
                                <button class="size-btn" onclick="setPreviewSize(758, 315)">758×315</button>
                                <button class="size-btn" onclick="setPreviewSize(1920, 1080)">1920×1080</button>
                                <button class="size-btn" onclick="setPreviewSize(1280, 720)">1280×720</button>
                                <button class="size-btn" onclick="setPreviewSize(800, 450)">800×450</button>
                            </div>
                        </div>
                        
                        <div style="margin-top: 12px;">
                            <div class="custom-size">
                                <div class="control-group">
                                    <label for="previewWidth">Width:</label>
                                    <input type="number" id="previewWidth" value="758" min="200" max="1920" onchange="updatePreviewSize()">
                                </div>
                                <div class="control-group">
                                    <label for="previewHeight">Height:</label>
                                    <input type="number" id="previewHeight" value="315" min="100" max="1080" onchange="updatePreviewSize()">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <div class="section-header active" onclick="toggleSection(this)">
                    <h3>Import Gradient</h3>
                    <span class="section-toggle expanded">▼</span>
                </div>
                <div class="section-content expanded">
                    <div class="control-group">
                        <label for="gradientImport">Paste CSS Gradient:</label>
                        <textarea id="gradientImport" placeholder="linear-gradient(to right, rgba(34, 29, 16, 1) 7%, rgba(31, 26, 15, 1) 20%, rgba(30, 25, 15, 0.8) 50%)" 
                                  style="width: 100%; height: 80px; padding: 8px; border: 1px solid #bdc3c7; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 11px; resize: vertical;"></textarea>
                    </div>
                    <div style="display: flex; gap: 8px; margin-top: 8px;">
                        <button onclick="importGradient()" style="background: #f39c12; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.2s ease; flex: 1;" onmouseover="this.style.background='#e67e22'" onmouseout="this.style.background='#f39c12'">📥 Import Gradient</button>
                        <button onclick="loadExampleGradient()" style="background: #6c757d; color: white; padding: 8px 12px; border: none; border-radius: 6px; font-size: 12px; cursor: pointer; transition: all 0.2s ease;" title="Load example gradient" onmouseover="this.style.background='#5a6268'" onmouseout="this.style.background='#6c757d'">📋 Example</button>
                    </div>
                    <div id="importStatus" style="margin-top: 8px; padding: 6px 8px; border-radius: 4px; font-size: 11px; display: none;"></div>
                </div>
            </div>

            <div class="section">
                <div class="section-header active" onclick="toggleSection(this)">
                    <h3>Color Stops</h3>
                    <span class="section-toggle expanded">▼</span>
                </div>
                <div class="section-content expanded">
                    <div id="colorStopsContainer" class="color-stops">
                        <!-- Color stops will be dynamically generated here -->
                    </div>
                    
                    <button id="addStopBtn" class="add-stop-btn" onclick="addColorStop()">+ Add Color Stop</button>
                </div>
            </div>

            <div class="section">
                <div class="section-header" onclick="toggleSection(this)">
                    <h3>Background Image</h3>
                    <span class="section-toggle">▶</span>
                </div>
                <div class="section-content">
                    <div class="image-controls-row">
                        <div class="file-upload-wrapper">
                            <button class="image-upload-btn">Choose Image</button>
                            <input type="file" id="backgroundImageUpload" accept="image/*" onchange="handleImageUpload(event)">
                        </div>
                        <button class="remove-image-btn" onclick="removeBackgroundImage()" id="removeImageBtn" disabled>Remove Image</button>
                    </div>
                    
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #dee2e6;">
                        <div class="control-group">
                            <label for="imageUrlInput">Image URL:</label>
                            <input type="url" id="imageUrlInput" placeholder="https://example.com/image.jpg" style="font-size: 12px;">
                        </div>
                        <button class="image-upload-btn" onclick="loadImageFromUrl()" id="loadUrlBtn" style="margin-top: 8px;">Load from URL</button>
                        <div id="urlStatus" style="margin-top: 8px; padding: 6px 8px; border-radius: 4px; font-size: 11px; display: none;"></div>
                    </div>
                    
                    <div class="image-position-controls" id="imagePositionControls" style="display: none;">
                        <div class="control-group">
                            <label for="imageSize">Image Size:</label>
                            <select id="imageSize" onchange="updateBackgroundImage()">
                                <option value="cover">Cover (Fill)</option>
                                <option value="contain">Contain (Fit)</option>
                                <option value="100%">Original Size</option>
                                <option value="150%">150%</option>
                                <option value="200%">200%</option>
                                <option value="50%">50%</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <label for="imagePosition">Position:</label>
                            <select id="imagePosition" onchange="updateBackgroundImage()">
                                <option value="center center">Center</option>
                                <option value="top left">Top Left</option>
                                <option value="top center">Top</option>
                                <option value="top right">Top Right</option>
                                <option value="center left">Left</option>
                                <option value="center right">Right</option>
                                <option value="bottom left">Bottom Left</option>
                                <option value="bottom center">Bottom</option>
                                <option value="bottom right">Bottom Right</option>
                            </select>
                        </div>
                    </div>
                    
                    <h4 style="margin: 15px 0 8px 0; font-size: 14px; color: #2c3e50;">Fine Position Adjustment</h4>
                    
                    <div class="position-fine-controls">
                        <div></div>
                        <div class="center-cell">
                            <button class="arrow-btn" onclick="moveImage(0, -10)" title="Move Up 10px">↑</button>
                        </div>
                        <div></div>
                        
                        <div class="center-cell">
                            <button class="arrow-btn" onclick="moveImage(-10, 0)" title="Move Left 10px">←</button>
                        </div>
                        <div class="center-cell">
                            <button class="reset-btn arrow-btn" onclick="resetImagePosition()" title="Reset Position">⟲</button>
                        </div>
                        <div class="center-cell">
                            <button class="arrow-btn" onclick="moveImage(10, 0)" title="Move Right 10px">→</button>
                        </div>
                        
                        <div></div>
                        <div class="center-cell">
                            <button class="arrow-btn" onclick="moveImage(0, 10)" title="Move Down 10px">↓</button>
                        </div>
                        <div></div>
                        
                                            <div style="grid-column: 1 / 4; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 8px;">
                        <div class="control-group">
                            <label for="imageOffsetX" style="font-size: 12px;">X Offset (px):</label>
                            <input type="number" id="imageOffsetX" value="0" onchange="applyImageOffset()" title="Horizontal offset in pixels" style="width: 100%;">
                        </div>
                        <div class="control-group">
                            <label for="imageOffsetY" style="font-size: 12px;">Y Offset (px):</label>
                            <input type="number" id="imageOffsetY" value="0" onchange="applyImageOffset()" title="Vertical offset in pixels" style="width: 100%;">
                        </div>
                    </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="main-preview">
            <div class="preview-container" id="previewContainer">
                <img id="backgroundImage" class="background-image" style="display: none;">
                <div class="gradient-overlay" id="gradientPreview"></div>
            </div>
            
            <div class="css-code-section" style="margin-top: 20px; text-align: center; width: 100%; display: flex; flex-direction: column; align-items: center;">
                <h4 style="margin: 0 0 10px 0; color: #2c3e50;">CSS Code:</h4>
                <div style="display: flex; align-items: center; gap: 8px; justify-content: center; max-width: 600px; width: 100%; margin: 0 auto;">
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; padding: 10px 12px; flex: 1; overflow-x: auto; min-width: 0; max-width: 550px;">
                        <code id="gradientCode" style="font-size: 12px; color: #2c3e50; font-family: 'Courier New', monospace; white-space: nowrap; display: block;">linear-gradient(to right, rgba(4, 3, 73, 1) 28%, rgba(4, 3, 73, 0.6) 65%, rgba(0, 0, 0, 0.4))</code>
                    </div>
                    <button onclick="copyGradientCode()" id="copyBtn" title="Copy CSS" style="background: #3498db; color: white; border: none; padding: 8px 10px; border-radius: 4px; font-size: 12px; cursor: pointer; transition: background 0.2s ease; flex-shrink: 0; min-width: 40px; height: 36px; width: 23px;" onmouseover="this.style.background='#2980b9'" onmouseout="this.style.background='#3498db'">📋</button>
                </div>
                <div id="copyFeedback" style="margin-top: 8px; font-size: 12px; color: #27ae60; display: none; text-align: center;">✓ Copied to clipboard!</div>
            </div>
        </div>
        
        <!-- Download Popup -->
        <div id="downloadPopup" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
            <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); max-width: 400px; width: 90%;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="margin: 0; color: #2c3e50;">Download Gradient</h3>
                    <button onclick="closeDownloadPopup()" style="background: none; border: none; font-size: 20px; cursor: pointer; color: #7f8c8d;">×</button>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 10px; font-weight: 500; color: #2c3e50;">Standard Sizes:</label>
                    <div class="size-options">
                        <button class="size-btn" onclick="downloadGradient(1920, 1080)">1920×1080</button>
                        <button class="size-btn" onclick="downloadGradient(1280, 720)">1280×720</button>
                        <button class="size-btn" onclick="downloadGradient(800, 450)">800×450</button>
                        <button class="size-btn" onclick="downloadGradient(400, 225)">400×225</button>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 10px; font-weight: 500; color: #2c3e50;">Custom Size:</label>
                    <div class="custom-size">
                        <input type="number" id="customWidth" value="1920" min="1" max="4000" placeholder="Width">
                        <input type="number" id="customHeight" value="1080" min="1" max="4000" placeholder="Height">
                    </div>
                    <button onclick="downloadCustomSize()" style="background: #27ae60; color: white; border: none; padding: 10px 20px; border-radius: 6px; margin-top: 10px; width: 100%; cursor: pointer;" onmouseover="this.style.background='#229954'" onmouseout="this.style.background='#27ae60'">Download Custom Size</button>
                </div>
            </div>
        </div>

        <canvas id="downloadCanvas" style="display: none;"></canvas>
    </div>

    <script>
        // Default gradient stops with unique IDs
        let nextStopId = 4;
        const gradientStops = [
            { id: 1, color: { r: 4, g: 3, b: 73, a: 1 }, position: 28 },
            { id: 2, color: { r: 4, g: 3, b: 73, a: 0.6 }, position: 65 },
            { id: 3, color: { r: 0, g: 0, b: 0, a: 0.4 }, position: 100 }
        ];
        
        // Preview size functionality
        function setPreviewSize(width, height) {
            document.getElementById('previewWidth').value = width;
            document.getElementById('previewHeight').value = height;
            updatePreviewSize();
        }
        
        function updatePreviewSize() {
            const width = parseInt(document.getElementById('previewWidth').value);
            const height = parseInt(document.getElementById('previewHeight').value);
            
            if (width > 0 && height > 0) {
                const previewContainer = document.getElementById('previewContainer');
                const gradientOverlay = document.getElementById('gradientPreview');
                const mainPreview = document.querySelector('.main-preview');
                
                // Update preview container size
                if (previewContainer) {
                    previewContainer.style.width = width + 'px';
                    previewContainer.style.height = height + 'px';
                }
                
                // Update gradient overlay size
                if (gradientOverlay) {
                    gradientOverlay.style.width = width + 'px';
                    gradientOverlay.style.height = height + 'px';
                }
                
                // Ensure proper scrolling for large sizes
                if (mainPreview) {
                    if (width > 1000 || height > 600) {
                        mainPreview.style.justifyContent = 'flex-start';
                        mainPreview.style.alignItems = 'flex-start';
                        mainPreview.style.paddingTop = '40px';
                    } else {
                        mainPreview.style.justifyContent = 'center';
                        mainPreview.style.alignItems = 'center';
                        mainPreview.style.paddingTop = '20px';
                    }
                }
                
                showFeedback(`Preview size updated to ${width}×${height}`, "info");
            }
        }
        
        // Download popup functionality
        function openDownloadPopup() {
            document.getElementById('downloadPopup').style.display = 'flex';
        }
        
        function closeDownloadPopup() {
            document.getElementById('downloadPopup').style.display = 'none';
        }
        
        // Close popup when clicking outside
        document.addEventListener('click', function(event) {
            const popup = document.getElementById('downloadPopup');
            if (event.target === popup) {
                closeDownloadPopup();
            }
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeDownloadPopup();
            }
            // Toggle sidebar with Ctrl+B or Cmd+B
            if ((event.ctrlKey || event.metaKey) && event.key === 'b') {
                event.preventDefault();
                toggleSidebar();
            }
        });
        
        // Sidebar toggle functionality
        function toggleSidebar() {
            const container = document.querySelector('.container');
            const sidebar = document.getElementById('sidebar');
            const toggleBtn = document.getElementById('sidebarToggle');
            
            container.classList.toggle('sidebar-collapsed');
            sidebar.classList.toggle('collapsed');
            toggleBtn.classList.toggle('collapsed');
            
            // Update button icon
            if (container.classList.contains('sidebar-collapsed')) {
                toggleBtn.textContent = '›';
                toggleBtn.title = 'Show Controls';
            } else {
                toggleBtn.textContent = '‹';
                toggleBtn.title = 'Hide Controls';
            }
        }
        
        // Accordion functionality
        function toggleSection(header) {
            const section = header.parentElement;
            const content = section.querySelector('.section-content');
            const toggle = header.querySelector('.section-toggle');
            
            // Toggle the expanded state
            const isExpanded = content.classList.contains('expanded');
            
            if (isExpanded) {
                // Collapse
                content.classList.remove('expanded');
                toggle.classList.remove('expanded');
                header.classList.remove('active');
                toggle.textContent = '▶';
            } else {
                // Expand
                content.classList.add('expanded');
                toggle.classList.add('expanded');
                header.classList.add('active');
                toggle.textContent = '▼';
            }
        }
        
        // Initialize the UI
        document.addEventListener('DOMContentLoaded', function() {
            renderColorStops();
            updateGradient();
            showFeedback("Welcome! Start by adjusting the colors and positions to create your gradient.", "info");
            
            // Initialize sidebar toggle button
            const toggleBtn = document.getElementById('sidebarToggle');
            toggleBtn.textContent = '‹';
            toggleBtn.title = 'Hide Controls';
            
            // Add Enter key support for URL input
            document.getElementById('imageUrlInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    loadImageFromUrl();
                }
            });
            
            // Add keyboard support for gradient import
            document.getElementById('gradientImport').addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    importGradient();
                }
            });
        });
        
        // Show feedback message
        function showFeedback(message, type = "success") {
            const feedback = document.getElementById('feedback');
            feedback.textContent = message;
            feedback.className = `feedback-message ${type}-message`;
            feedback.style.display = 'block';
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                feedback.classList.add('fadeOut');
                setTimeout(() => {
                    feedback.style.display = 'none';
                    feedback.classList.remove('fadeOut');
                }, 500);
            }, 5000);
        }
        
        // Convert RGB to Hex
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        
        // Convert Hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        // Parse various color formats
        function parseColorInput(input) {
            const trimmed = input.trim();
            
            // Try hex format (#FF0000 or FF0000)
            const hexMatch = /^#?([a-f\d]{6})$/i.exec(trimmed);
            if (hexMatch) {
                const hex = '#' + hexMatch[1];
                const rgb = hexToRgb(hex);
                return rgb ? { ...rgb, a: 1 } : null;
            }
            
            // Try short hex format (#F00)
            const shortHexMatch = /^#?([a-f\d])([a-f\d])([a-f\d])$/i.exec(trimmed);
            if (shortHexMatch) {
                const hex = '#' + shortHexMatch[1] + shortHexMatch[1] + shortHexMatch[2] + shortHexMatch[2] + shortHexMatch[3] + shortHexMatch[3];
                const rgb = hexToRgb(hex);
                return rgb ? { ...rgb, a: 1 } : null;
            }
            
            // Try rgb format (rgb(255, 0, 0))
            const rgbMatch = /^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i.exec(trimmed);
            if (rgbMatch) {
                const r = parseInt(rgbMatch[1]);
                const g = parseInt(rgbMatch[2]);
                const b = parseInt(rgbMatch[3]);
                if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
                    return { r, g, b, a: 1 };
                }
            }
            
            // Try rgba format (rgba(255, 0, 0, 0.5))
            const rgbaMatch = /^rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([0-1]?\.?\d*)\s*\)$/i.exec(trimmed);
            if (rgbaMatch) {
                const r = parseInt(rgbaMatch[1]);
                const g = parseInt(rgbaMatch[2]);
                const b = parseInt(rgbaMatch[3]);
                const a = parseFloat(rgbaMatch[4]);
                if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255 && a >= 0 && a <= 1) {
                    return { r, g, b, a };
                }
            }
            
            return null;
        }
        
        // Format RGBA string
        function formatRgba(color) {
            return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;
        }
        
        // Parse CSS gradient string
        function parseGradient(gradientString) {
            try {
                // Clean up the string
                const cleaned = gradientString.trim().replace(/\s+/g, ' ');
                
                // Extract the linear-gradient content
                const match = cleaned.match(/linear-gradient\s*\(\s*(.*)\s*\)/i);
                if (!match) {
                    throw new Error('Not a valid linear-gradient');
                }
                
                const content = match[1];
                const parts = [];
                let currentPart = '';
                let parenDepth = 0;
                let inQuotes = false;
                
                // Split by commas, respecting parentheses and quotes
                for (let i = 0; i < content.length; i++) {
                    const char = content[i];
                    if (char === '"' || char === "'") {
                        inQuotes = !inQuotes;
                    } else if (!inQuotes) {
                        if (char === '(') parenDepth++;
                        else if (char === ')') parenDepth--;
                        else if (char === ',' && parenDepth === 0) {
                            parts.push(currentPart.trim());
                            currentPart = '';
                            continue;
                        }
                    }
                    currentPart += char;
                }
                if (currentPart.trim()) {
                    parts.push(currentPart.trim());
                }
                
                // First part might be direction
                let direction = 'to right';
                let colorStopsStart = 0;
                
                const firstPart = parts[0].toLowerCase();
                if (firstPart.includes('to ') || firstPart.includes('deg') || firstPart.includes('rad') || firstPart.includes('turn')) {
                    direction = firstPart;
                    colorStopsStart = 1;
                }
                
                // Parse color stops
                const parsedStops = [];
                for (let i = colorStopsStart; i < parts.length; i++) {
                    const stopString = parts[i].trim();
                    const colorStop = parseColorStop(stopString);
                    if (colorStop) {
                        parsedStops.push(colorStop);
                    }
                }
                
                return {
                    direction: direction,
                    stops: parsedStops
                };
                
            } catch (error) {
                console.error('Gradient parsing error:', error);
                throw error;
            }
        }
        
        // Parse individual color stop
        function parseColorStop(stopString) {
            // Handle various formats: "rgba(255,0,0,1) 50%" or "#ff0000 25%" or "red 10%"
            
            // Try to extract position (percentage)
            let position = 100; // default
            const positionMatch = stopString.match(/(\d+(?:\.\d+)?)\s*%\s*$/);
            if (positionMatch) {
                position = parseFloat(positionMatch[1]);
                stopString = stopString.replace(/\s*\d+(?:\.\d+)?\s*%\s*$/, '').trim();
            }
            
            // Parse color part
            let color = null;
            
            // Try rgba/rgb format
            const rgbaMatch = stopString.match(/rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([0-1]?\.?\d*))?\s*\)/i);
            if (rgbaMatch) {
                color = {
                    r: parseInt(rgbaMatch[1]),
                    g: parseInt(rgbaMatch[2]),
                    b: parseInt(rgbaMatch[3]),
                    a: rgbaMatch[4] ? parseFloat(rgbaMatch[4]) : 1
                };
            }
            
            // Try hex format
            if (!color) {
                const hexMatch = stopString.match(/#([a-f\d]{6}|[a-f\d]{3})/i);
                if (hexMatch) {
                    let hex = hexMatch[1];
                    if (hex.length === 3) {
                        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
                    }
                    const rgb = hexToRgb('#' + hex);
                    if (rgb) {
                        color = { ...rgb, a: 1 };
                    }
                }
            }
            
            // Try named colors (basic set)
            if (!color) {
                const namedColors = {
                    'red': { r: 255, g: 0, b: 0, a: 1 },
                    'green': { r: 0, g: 128, b: 0, a: 1 },
                    'blue': { r: 0, g: 0, b: 255, a: 1 },
                    'white': { r: 255, g: 255, b: 255, a: 1 },
                    'black': { r: 0, g: 0, b: 0, a: 1 },
                    'transparent': { r: 0, g: 0, b: 0, a: 0 }
                };
                const colorName = stopString.toLowerCase().trim();
                if (namedColors[colorName]) {
                    color = namedColors[colorName];
                }
            }
            
            if (!color) {
                console.warn('Could not parse color:', stopString);
                return null;
            }
            
            return { color, position };
        }
        
        // Show import status messages
        function showImportStatus(message, type) {
            const importStatus = document.getElementById('importStatus');
            importStatus.textContent = message;
            importStatus.style.display = 'block';
            
            // Set colors based on type
            switch(type) {
                case 'success':
                    importStatus.style.backgroundColor = '#d4edda';
                    importStatus.style.color = '#155724';
                    importStatus.style.border = '1px solid #c3e6cb';
                    break;
                case 'error':
                    importStatus.style.backgroundColor = '#f8d7da';
                    importStatus.style.color = '#721c24';
                    importStatus.style.border = '1px solid #f5c6cb';
                    break;
                case 'info':
                    importStatus.style.backgroundColor = '#d1ecf1';
                    importStatus.style.color = '#0c5460';
                    importStatus.style.border = '1px solid #bee5eb';
                    break;
            }
            
            // Auto-hide after 5 seconds for success messages
            if (type === 'success') {
                setTimeout(() => {
                    importStatus.style.display = 'none';
                }, 5000);
            }
        }
        
        // Import gradient from CSS string
        function importGradient() {
            const gradientInput = document.getElementById('gradientImport');
            const gradientString = gradientInput.value.trim();
            
            if (!gradientString) {
                showImportStatus("Please paste a CSS gradient string.", "error");
                return;
            }
            
            try {
                const parsed = parseGradient(gradientString);
                
                if (parsed.stops.length < 2) {
                    showImportStatus("Gradient must have at least 2 color stops.", "error");
                    return;
                }
                
                // Clear existing stops
                gradientStops.length = 0;
                nextStopId = 1;
                
                // Add parsed stops
                parsed.stops.forEach(stop => {
                    gradientStops.push({
                        id: nextStopId++,
                        color: stop.color,
                        position: stop.position
                    });
                });
                
                // Set direction
                const directionSelect = document.getElementById('gradientDirection');
                const directionMap = {
                    'to right': 'to right',
                    'to left': 'to left',
                    'to bottom': 'to bottom',
                    'to top': 'to top',
                    'to bottom right': 'to bottom right',
                    'to bottom left': 'to bottom left',
                    'to top right': 'to top right',
                    'to top left': 'to top left'
                };
                
                if (directionMap[parsed.direction]) {
                    directionSelect.value = directionMap[parsed.direction];
                } else {
                    directionSelect.value = 'to right'; // fallback
                }
                
                // Update UI
                renderColorStops();
                updateGradient();
                
                showImportStatus(`✓ Imported gradient with ${parsed.stops.length} color stops!`, "success");
                showFeedback("Gradient imported successfully! All color stops have been updated.", "success");
                
                // Clear the input
                gradientInput.value = '';
                
            } catch (error) {
                showImportStatus("Failed to parse gradient. Please check the format.", "error");
                                 console.error('Import error:', error);
             }
         }
         
         // Load example gradient
         function loadExampleGradient() {
             const exampleGradient = 'linear-gradient(to right, rgba(34, 29, 16, 1) 7%, rgba(31, 26, 15, 1) 20%, rgba(30, 25, 15, 0.8) 50%, rgba(29, 24, 14, 0.4) 68%, rgba(29, 24, 14, 0.2) 100%)';
             
             document.getElementById('gradientImport').value = exampleGradient;
             importGradient();
         }
        
        // Update range slider visual fill
        function updateRangeSlider(slider, value, min, max) {
            if (!slider) return;
            const percentage = ((value - min) / (max - min)) * 100;
            slider.style.background = `linear-gradient(to right, #3498db 0%, #3498db ${percentage}%, #dee2e6 ${percentage}%, #dee2e6 100%)`;
        }
        
        // Find stop by ID
        function findStopById(id) {
            return gradientStops.find(stop => stop.id === id);
        }
        
        // Find stop index by ID
        function findStopIndexById(id) {
            return gradientStops.findIndex(stop => stop.id === id);
        }
        
        // Update color value displays
        function updateColorValues(stopId) {
            const stop = findStopById(stopId);
            if (!stop) return;
            
            const hexColor = rgbToHex(stop.color.r, stop.color.g, stop.color.b);
            
            const hexSpan = document.getElementById(`hex-${stopId}`);
            const rgbSpan = document.getElementById(`rgb-${stopId}`);
            const rgbaSpan = document.getElementById(`rgba-${stopId}`);
            const colorInput = document.getElementById(`color-input-${stopId}`);
            
            if (hexSpan) hexSpan.textContent = hexColor.toUpperCase();
            if (rgbSpan) rgbSpan.textContent = `rgb(${stop.color.r}, ${stop.color.g}, ${stop.color.b})`;
            if (rgbaSpan) rgbaSpan.textContent = formatRgba(stop.color);
            
            // Update text input field with hex value
            if (colorInput) {
                colorInput.value = hexColor.toUpperCase();
            }
            
            // Update color picker
            const colorPicker = document.querySelector(`[data-stop-id="${stopId}"] input[type="color"]`);
            if (colorPicker) {
                colorPicker.value = hexColor;
            }
            
            // Update color preview
            const colorPreview = document.querySelector(`[data-stop-id="${stopId}"] .color-preview`);
            if (colorPreview) {
                colorPreview.style.background = formatRgba(stop.color);
            }
        }
        
        // Render all color stops in the UI
        function renderColorStops() {
            const container = document.getElementById('colorStopsContainer');
            
            // Preserve scroll position
            const scrollTop = container.scrollTop;
            
            container.innerHTML = '';
            
            // Sort stops by position for display, but maintain original array order
            const sortedStops = [...gradientStops].sort((a, b) => a.position - b.position);
            
            sortedStops.forEach((stop, displayIndex) => {
                const hexColor = rgbToHex(stop.color.r, stop.color.g, stop.color.b);
                const stopElement = document.createElement('div');
                stopElement.className = 'color-stop';
                stopElement.setAttribute('data-stop-id', stop.id);
                stopElement.innerHTML = `
                    <div class="color-preview" style="background: ${formatRgba(stop.color)};"></div>
                    <div class="color-input-group">
                        <div class="color-input-row color-main">
                            <label>Color:</label>
                            <input type="color" value="${hexColor}" onchange="updateColorFromHex(${stop.id}, this.value)" title="Choose a color" style="width: 50px; height: 32px;">
                            <input type="text" id="color-input-${stop.id}" value="${hexColor}" placeholder="Enter hex, rgb, or rgba" onchange="updateColorFromInput(${stop.id}, this.value)" style="flex: 1; font-family: 'Courier New', monospace; font-size: 12px;" title="Type hex (#FF0000), rgb(255,0,0), or rgba(255,0,0,1)">
                        </div>
                        <div style="margin: 4px 0; padding: 6px; background: #ffffff; border-radius: 3px; border: 1px solid #e9ecef; font-size: 10px;">
                            <div style="color: #6c757d; margin-bottom: 3px; font-weight: 500;">Values:</div>
                            <div style="font-family: 'Courier New', monospace; line-height: 1.3; color: #495057;">
                                <div style="margin-bottom: 1px;"><strong>HEX:</strong> <span id="hex-${stop.id}">${hexColor.toUpperCase()}</span></div>
                                <div style="margin-bottom: 1px;"><strong>RGB:</strong> <span id="rgb-${stop.id}">rgb(${stop.color.r}, ${stop.color.g}, ${stop.color.b})</span></div>
                                <div><strong>RGBA:</strong> <span id="rgba-${stop.id}">${formatRgba(stop.color)}</span></div>
                            </div>
                        </div>
                        <div class="color-input-row">
                            <label>Position:</label>
                            <input type="number" value="${stop.position}" min="0" max="100" oninput="updateStopPosition(${stop.id}, this.value)" id="position-number-${stop.id}" title="Position in percentage (0-100%)">
                            <input type="range" value="${stop.position}" min="0" max="100" oninput="updateStopPosition(${stop.id}, this.value)" id="position-range-${stop.id}" style="background: linear-gradient(to right, #3498db 0%, #3498db ${stop.position}%, #dee2e6 ${stop.position}%, #dee2e6 100%);">
                            <span>%</span>
                        </div>
                        <div class="color-input-row">
                            <label>Opacity:</label>
                            <input type="number" value="${stop.color.a}" min="0" max="1" step="0.1" oninput="updateStopOpacity(${stop.id}, this.value)" id="opacity-number-${stop.id}" title="Opacity value (0-1)">
                            <input type="range" value="${stop.color.a}" min="0" max="1" step="0.1" oninput="updateStopOpacity(${stop.id}, this.value)" id="opacity-range-${stop.id}" style="background: linear-gradient(to right, #3498db 0%, #3498db ${stop.color.a * 100}%, #dee2e6 ${stop.color.a * 100}%, #dee2e6 100%);">
                        </div>
                    </div>
                    ${gradientStops.length > 2 ? '<button class="remove-stop-btn" onclick="removeColorStop(' + stop.id + ')" title="Remove this color stop">Remove</button>' : ''}
                `;
                container.appendChild(stopElement);
            });
            
            // Restore scroll position
            container.scrollTop = scrollTop;
        }
        
        // Update color from hex input
        function updateColorFromHex(stopId, hexValue) {
            const stop = findStopById(stopId);
            const rgb = hexToRgb(hexValue);
            if (rgb && stop) {
                stop.color.r = rgb.r;
                stop.color.g = rgb.g;
                stop.color.b = rgb.b;
                updateColorValues(stopId);
                updateGradient();
                showFeedback("Color updated! Your gradient has been refreshed.", "success");
            }
        }
        
        // Update color from text input (supports hex, rgb, rgba)
        function updateColorFromInput(stopId, inputValue) {
            const colorInput = document.getElementById(`color-input-${stopId}`);
            const parsedColor = parseColorInput(inputValue);
            const stop = findStopById(stopId);
            
            if (parsedColor && stop) {
                stop.color.r = parsedColor.r;
                stop.color.g = parsedColor.g;
                stop.color.b = parsedColor.b;
                stop.color.a = parsedColor.a;
                
                // Update all inputs and displays
                updateColorValues(stopId);
                updateGradient();
                
                // Reset input style to show success
                colorInput.style.borderColor = '#27ae60';
                colorInput.style.backgroundColor = '#d4edda';
                
                // Reset style after a short delay
                setTimeout(() => {
                    colorInput.style.borderColor = '';
                    colorInput.style.backgroundColor = '';
                }, 1000);
                
                showFeedback("Color updated! Your gradient has been refreshed.", "success");
            } else {
                // Show error styling
                colorInput.style.borderColor = '#e74c3c';
                colorInput.style.backgroundColor = '#f8d7da';
                
                // Reset style after a short delay
                setTimeout(() => {
                    colorInput.style.borderColor = '';
                    colorInput.style.backgroundColor = '';
                }, 2000);
                
                showFeedback("Invalid color format. Try: #FF0000, rgb(255,0,0), or rgba(255,0,0,1)", "info");
            }
        }
        
        // Update stop position
        function updateStopPosition(stopId, value) {
            const positionValue = parseInt(value);
            const stop = findStopById(stopId);
            
            if (!stop) return;
            
            stop.position = positionValue;
            
            // Update the specific inputs that triggered this change
            const numberInput = document.getElementById(`position-number-${stopId}`);
            const rangeInput = document.getElementById(`position-range-${stopId}`);
            
            if (numberInput) numberInput.value = positionValue;
            if (rangeInput) rangeInput.value = positionValue;
            
            // Update range slider fill
            updateRangeSlider(rangeInput, positionValue, 0, 100);
            
            // Re-render to show stops in correct order (now efficient with scroll preservation)
            renderColorStops();
            
            updateGradient();
        }
        
        // Update stop opacity
        function updateStopOpacity(stopId, value) {
            const opacityValue = parseFloat(value);
            const stop = findStopById(stopId);
            
            if (!stop) return;
            
            stop.color.a = opacityValue;
            
            // Sync the range and number inputs
            const numberInput = document.getElementById(`opacity-number-${stopId}`);
            const rangeInput = document.getElementById(`opacity-range-${stopId}`);
            
            if (numberInput) numberInput.value = opacityValue;
            if (rangeInput) rangeInput.value = opacityValue;
            
            // Update range slider fill
            updateRangeSlider(rangeInput, opacityValue, 0, 1);
            
            updateColorValues(stopId);
            updateGradient();
        }
        
        // Add a new color stop
        function addColorStop() {
            // Always add new color stops at the end (100% position)
            const newPosition = 100;
            
            // Use white color with full opacity as default
            const defaultColor = { r: 255, g: 255, b: 255, a: 1 };
            
            gradientStops.push({
                id: nextStopId++,
                color: defaultColor,
                position: newPosition
            });
            
            renderColorStops();
            updateGradient();
            
            showFeedback("New white color stop added at 100%! Customize it to enhance your gradient.", "success");
        }
        
        // Remove a color stop
        function removeColorStop(stopId) {
            if (gradientStops.length > 2) {
                const index = findStopIndexById(stopId);
                if (index !== -1) {
                    gradientStops.splice(index, 1);
                    renderColorStops();
                    updateGradient();
                    showFeedback("Color stop removed. Your gradient has been updated.", "info");
                }
            } else {
                showFeedback("You need at least 2 color stops for a gradient. Cannot remove.", "info");
            }
        }
        
        // Update the gradient preview and code
        function updateGradient() {
            const direction = document.getElementById('gradientDirection').value;
            let gradientCSS = `linear-gradient(${direction}`;
            
            // Sort stops by position
            const sortedStops = [...gradientStops].sort((a, b) => a.position - b.position);
            
            sortedStops.forEach(stop => {
                const rgba = formatRgba(stop.color);
                gradientCSS += `, ${rgba} ${stop.position}%`;
            });
            
            gradientCSS += ')';
            
            // Update the preview
            document.getElementById('gradientPreview').style.background = gradientCSS;
            
            // Update the code display
            document.getElementById('gradientCode').textContent = gradientCSS;
        }
        
        // Background image handling
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (file && file.type.match('image.*')) {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const backgroundImage = document.getElementById('backgroundImage');
                    backgroundImage.src = e.target.result;
                    backgroundImage.style.display = 'block';
                    
                    // Enable image controls
                    document.getElementById('imagePositionControls').style.display = 'grid';
                    document.getElementById('removeImageBtn').disabled = false;
                    
                    // Expand background image section if it's collapsed
                    const bgImageSection = document.querySelector('.section:nth-child(3)'); // Background image is 3rd section
                    const bgImageHeader = bgImageSection.querySelector('.section-header');
                    const bgImageContent = bgImageSection.querySelector('.section-content');
                    const bgImageToggle = bgImageHeader.querySelector('.section-toggle');
                    if (!bgImageContent.classList.contains('expanded')) {
                        bgImageContent.classList.add('expanded');
                        bgImageHeader.classList.add('active');
                        bgImageToggle.classList.add('expanded');
                        bgImageToggle.textContent = '▼';
                    }
                    
                    // Reset offsets when loading a new image
                    document.getElementById('imageOffsetX').value = 0;
                    document.getElementById('imageOffsetY').value = 0;
                    
                    // Clear URL input and status since we're using file upload
                    document.getElementById('imageUrlInput').value = '';
                    document.getElementById('urlStatus').style.display = 'none';
                    
                    updateBackgroundImage();
                    showFeedback("Background image uploaded successfully!", "success");
                };
                
                reader.readAsDataURL(file);
            }
        }
        
        // Load image from URL
        function loadImageFromUrl() {
            const urlInput = document.getElementById('imageUrlInput');
            const imageUrl = urlInput.value.trim();
            const urlStatus = document.getElementById('urlStatus');
            
            if (!imageUrl) {
                showUrlStatus("Please enter a valid image URL.", "error");
                return;
            }
            
            // Validate URL format
            try {
                new URL(imageUrl);
            } catch (e) {
                showUrlStatus("Please enter a valid URL format.", "error");
                return;
            }
            
            // Show loading feedback
            showUrlStatus("Loading image...", "loading");
            
            // Create a new image to test if URL is valid
            const testImage = new Image();
            
            testImage.onload = function() {
                const backgroundImage = document.getElementById('backgroundImage');
                backgroundImage.src = imageUrl;
                backgroundImage.style.display = 'block';
                
                // Enable image controls
                document.getElementById('imagePositionControls').style.display = 'grid';
                document.getElementById('removeImageBtn').disabled = false;
                
                // Expand background image section if it's collapsed
                const bgImageSection = document.querySelector('.section:nth-child(3)'); // Background image is 3rd section
                const bgImageHeader = bgImageSection.querySelector('.section-header');
                const bgImageContent = bgImageSection.querySelector('.section-content');
                const bgImageToggle = bgImageHeader.querySelector('.section-toggle');
                if (!bgImageContent.classList.contains('expanded')) {
                    bgImageContent.classList.add('expanded');
                    bgImageHeader.classList.add('active');
                    bgImageToggle.classList.add('expanded');
                    bgImageToggle.textContent = '▼';
                }
                
                // Reset offsets when loading a new image
                document.getElementById('imageOffsetX').value = 0;
                document.getElementById('imageOffsetY').value = 0;
                
                updateBackgroundImage();
                
                // Show success with truncated URL
                const truncatedUrl = imageUrl.length > 50 ? imageUrl.substring(0, 47) + '...' : imageUrl;
                showUrlStatus(`✓ Loaded: ${truncatedUrl}`, "success");
                showFeedback("Background image loaded successfully from URL!", "success");
            };
            
            testImage.onerror = function() {
                showUrlStatus("Failed to load image. Check URL and try again.", "error");
                showFeedback("Failed to load image from URL. Please check the URL and try again.", "info");
            };
            
            // Set crossOrigin to handle CORS if needed
            testImage.crossOrigin = "anonymous";
            testImage.src = imageUrl;
        }
        
        // Show URL status messages
        function showUrlStatus(message, type) {
            const urlStatus = document.getElementById('urlStatus');
            urlStatus.textContent = message;
            urlStatus.style.display = 'block';
            
            // Set colors based on type
            switch(type) {
                case 'success':
                    urlStatus.style.backgroundColor = '#d4edda';
                    urlStatus.style.color = '#155724';
                    urlStatus.style.border = '1px solid #c3e6cb';
                    break;
                case 'error':
                    urlStatus.style.backgroundColor = '#f8d7da';
                    urlStatus.style.color = '#721c24';
                    urlStatus.style.border = '1px solid #f5c6cb';
                    break;
                case 'loading':
                    urlStatus.style.backgroundColor = '#d1ecf1';
                    urlStatus.style.color = '#0c5460';
                    urlStatus.style.border = '1px solid #bee5eb';
                    break;
            }
            
            // Auto-hide after 5 seconds for success messages
            if (type === 'success') {
                setTimeout(() => {
                    urlStatus.style.display = 'none';
                }, 5000);
            }
        }
        
        // Copy gradient CSS code to clipboard
        function copyGradientCode() {
            const gradientCode = document.getElementById('gradientCode').textContent;
            const copyBtn = document.getElementById('copyBtn');
            const copyFeedback = document.getElementById('copyFeedback');
            
            // Use the modern clipboard API
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(gradientCode).then(() => {
                    showCopySuccess();
                }).catch(err => {
                    // Fallback to older method
                    fallbackCopyTextToClipboard(gradientCode);
                });
            } else {
                // Fallback for older browsers or non-secure contexts
                fallbackCopyTextToClipboard(gradientCode);
            }
            
            function showCopySuccess() {
                // Show visual feedback
                copyFeedback.style.display = 'block';
                copyBtn.textContent = '✓';
                copyBtn.style.background = '#27ae60';
                
                // Reset button after 2 seconds
                setTimeout(() => {
                    copyFeedback.style.display = 'none';
                    copyBtn.textContent = '📋';
                    copyBtn.style.background = '#3498db';
                }, 2000);
                
                // Show main feedback
                showFeedback("Gradient CSS code copied to clipboard!", "success");
            }
            
            function fallbackCopyTextToClipboard(text) {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.left = "-999999px";
                textArea.style.top = "-999999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    document.execCommand('copy');
                    showCopySuccess();
                } catch (err) {
                    showFeedback("Failed to copy. Please select and copy manually.", "info");
                }
                
                document.body.removeChild(textArea);
            }
        }
        
        function updateBackgroundImage() {
            const backgroundImage = document.getElementById('backgroundImage');
            const size = document.getElementById('imageSize').value;
            const position = document.getElementById('imagePosition').value;
            
            backgroundImage.style.objectFit = size === 'cover' || size === 'contain' ? size : 'none';
            
            if (size !== 'cover' && size !== 'contain') {
                backgroundImage.style.width = size;
                backgroundImage.style.height = 'auto';
            } else {
                backgroundImage.style.width = '100%';
                backgroundImage.style.height = '100%';
            }
            
            const [vertical, horizontal] = position.split(' ');
            backgroundImage.style.objectPosition = position;
            
            // Calculate position if not using object-fit
            if (size !== 'cover' && size !== 'contain') {
                let top = '50%', left = '50%';
                
                if (vertical === 'top') top = '0';
                else if (vertical === 'bottom') top = '100%';
                
                if (horizontal === 'left') left = '0';
                else if (horizontal === 'right') left = '100%';
                
                backgroundImage.style.top = top;
                backgroundImage.style.left = left;
                backgroundImage.style.transform = 'translate(-50%, -50%)';
                
                // Adjust transform origin based on position
                if (vertical === 'top') backgroundImage.style.transformOrigin = `top ${horizontal}`;
                else if (vertical === 'bottom') backgroundImage.style.transformOrigin = `bottom ${horizontal}`;
                else backgroundImage.style.transformOrigin = `center ${horizontal}`;
            }
            
            // Apply any custom offsets
            applyImageOffset();
        }
        
        function moveImage(deltaX, deltaY) {
            const xOffset = parseInt(document.getElementById('imageOffsetX').value || 0);
            const yOffset = parseInt(document.getElementById('imageOffsetY').value || 0);
            
            document.getElementById('imageOffsetX').value = xOffset + deltaX;
            document.getElementById('imageOffsetY').value = yOffset + deltaY;
            
            applyImageOffset();
        }
        
        function applyImageOffset() {
            const backgroundImage = document.getElementById('backgroundImage');
            const xOffset = parseInt(document.getElementById('imageOffsetX').value || 0);
            const yOffset = parseInt(document.getElementById('imageOffsetY').value || 0);
            
            // Get the size setting
            const size = document.getElementById('imageSize').value;
            
            // Different handling based on object-fit mode
            if (size === 'cover' || size === 'contain') {
                // For object-fit modes, we need to parse the current position
                let baseX = '50%';
                let baseY = '50%';
                
                // Get the base position from the dropdown
                const positionSetting = document.getElementById('imagePosition').value;
                const [vertical, horizontal] = positionSetting.split(' ');
                
                // Convert position keywords to percentages
                if (horizontal === 'left') baseX = '0%';
                else if (horizontal === 'right') baseX = '100%';
                else baseX = '50%';
                
                if (vertical === 'top') baseY = '0%';
                else if (vertical === 'bottom') baseY = '100%';
                else baseY = '50%';
                
                // Apply the pixel offsets directly to object-position
                backgroundImage.style.objectPosition = `calc(${baseX} + ${xOffset}px) calc(${baseY} + ${yOffset}px)`;
            } else {
                // For non-object-fit images
                // First determine the base position
                const positionSetting = document.getElementById('imagePosition').value;
                const [vertical, horizontal] = positionSetting.split(' ');
                
                let baseX = '50%';
                let baseY = '50%';
                let translateX = '-50%';
                let translateY = '-50%';
                
                // Set base position
                if (horizontal === 'left') {
                    baseX = '0%';
                    translateX = '0%';
                } else if (horizontal === 'right') {
                    baseX = '100%';
                    translateX = '-100%';
                }
                
                if (vertical === 'top') {
                    baseY = '0%';
                    translateY = '0%';
                } else if (vertical === 'bottom') {
                    baseY = '100%';
                    translateY = '-100%';
                }
                
                // Apply position with offsets
                backgroundImage.style.top = baseY;
                backgroundImage.style.left = baseX;
                backgroundImage.style.transform = `translate(calc(${translateX} + ${xOffset}px), calc(${translateY} + ${yOffset}px))`;
            }
            
            // Log the current position for debugging
            console.log(`Image position: x=${xOffset}px, y=${yOffset}px, objectFit=${backgroundImage.style.objectFit}, objectPosition=${backgroundImage.style.objectPosition}`);
        }
        
        function resetImagePosition() {
            document.getElementById('imageOffsetX').value = 0;
            document.getElementById('imageOffsetY').value = 0;
            updateBackgroundImage();
            showFeedback("Image position reset to default.", "info");
        }
        
        function removeBackgroundImage() {
            const backgroundImage = document.getElementById('backgroundImage');
            backgroundImage.src = '';
            backgroundImage.style.display = 'none';
            
            // Disable image controls
            document.getElementById('imagePositionControls').style.display = 'none';
            document.getElementById('removeImageBtn').disabled = true;
            
            // Reset file input and URL input
            document.getElementById('backgroundImageUpload').value = '';
            document.getElementById('imageUrlInput').value = '';
            
            // Clear URL status
            document.getElementById('urlStatus').style.display = 'none';
            
            showFeedback("Background image removed.", "info");
        }
        
        function createGradientCanvas(width, height) {
            const canvas = document.getElementById('downloadCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = width;
            canvas.height = height;
            
            // Get the current gradient direction
            const direction = document.getElementById('gradientDirection').value;
            
            // Determine gradient coordinates based on direction
            let x0 = 0, y0 = 0, x1 = 0, y1 = 0;
            
            switch (direction) {
                case 'to right':
                    x1 = width;
                    break;
                case 'to left':
                    x0 = width;
                    break;
                case 'to bottom':
                    y1 = height;
                    break;
                case 'to top':
                    y0 = height;
                    break;
                case 'to bottom right':
                    x1 = width;
                    y1 = height;
                    break;
                case 'to bottom left':
                    x0 = width;
                    y1 = height;
                    break;
                case 'to top right':
                    x1 = width;
                    y0 = height;
                    break;
                case 'to top left':
                    x0 = width;
                    y0 = height;
                    break;
                default:
                    x1 = width;
            }
            
            // Create linear gradient
            const gradient = ctx.createLinearGradient(x0, y0, x1, y1);
            
            // Sort stops by position
            const sortedStops = [...gradientStops].sort((a, b) => a.position - b.position);
            
            // Add color stops
            sortedStops.forEach(stop => {
                gradient.addColorStop(stop.position / 100, formatRgba(stop.color));
            });
            
            // Fill the canvas with gradient
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            return canvas;
        }
        
        function downloadGradient(width, height) {
            const canvas = createGradientCanvas(width, height);
            
            // Convert to blob and download
            canvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `gradient_${width}x${height}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showFeedback(`Gradient image (${width}×${height}) downloaded successfully!`, "success");
                closeDownloadPopup();
            }, 'image/png');
        }
        
        function downloadCustomSize() {
            const width = parseInt(document.getElementById('customWidth').value);
            const height = parseInt(document.getElementById('customHeight').value);
            
            if (width > 0 && height > 0) {
                if (width > 4000 || height > 4000) {
                    showFeedback("Image dimensions too large. Please use values below 4000px.", "info");
                } else {
                    downloadGradient(width, height);
                }
            } else {
                showFeedback("Please enter valid width and height values greater than 0.", "info");
            }
        }
    </script>
</body>
</html>